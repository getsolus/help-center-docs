"use strict";(self.webpackChunksolus_help_center=self.webpackChunksolus_help_center||[]).push([[1617],{38491:(e,a,s)=>{s.r(a),s.d(a,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>t,metadata:()=>c,toc:()=>d});var n=s(85893),i=s(11151);const t={title:"Rebuilding a stack",summary:"Rebuilding a stack of package dependencies"},r="Rebuilding a stack",c={id:"packaging/stack-rebuilds",title:"Rebuilding a stack",description:"In packaging, a stack is a package and the packages that depend on it. Most commonly, this refers to libraries, such as the Poppler stack, but other software can be referred to a stack as well. One example is the GNOME stack, which includes the libraries and applications that are the core of the GNOME desktop environment. Packages that depend on another package are called that package's reverse dependencies. When updating a library, one has to be mindful of its reverse dependencies, and if they will need to be rebuilt after updating the library.",source:"@site/docs/packaging/stack-rebuilds.md",sourceDirName:"packaging",slug:"/packaging/stack-rebuilds",permalink:"/docs/packaging/stack-rebuilds",draft:!1,unlisted:!1,editUrl:"https://github.com/getsolus/help-center-docs/tree/master/docs/packaging/stack-rebuilds.md",tags:[],version:"current",lastUpdatedAt:1732248028e3,frontMatter:{title:"Rebuilding a stack",summary:"Rebuilding a stack of package dependencies"},sidebar:"packagingSidebar",previous:{title:"Requesting a Package",permalink:"/docs/packaging/procedures/request-a-package"},next:{title:"Translation instructions",permalink:"/docs/packaging/translation-instructions"}},l={},d=[{value:"Updating the library",id:"updating-the-library",level:2},{value:"What are symbols?",id:"what-are-symbols",level:2},{value:"Checking if rebuilds are necessary",id:"checking-if-rebuilds-are-necessary",level:2},{value:"Finding reverse dependencies",id:"finding-reverse-dependencies",level:2},{value:"Rebuild the stack",id:"rebuild-the-stack",level:2}];function o(e){const a={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(a.header,{children:(0,n.jsx)(a.h1,{id:"rebuilding-a-stack",children:"Rebuilding a stack"})}),"\n",(0,n.jsxs)(a.p,{children:["In packaging, a stack is a package and the packages that depend on it. Most commonly, this refers to libraries, such as the Poppler stack, but other software can be referred to a stack as well. One example is the GNOME stack, which includes the libraries and applications that are the core of the GNOME desktop environment. Packages that depend on another package are called that package's ",(0,n.jsx)(a.em,{children:"reverse dependencies"}),". When updating a library, one has to be mindful of its reverse dependencies, and if they will need to be rebuilt after updating the library."]}),"\n",(0,n.jsx)(a.admonition,{type:"note",children:(0,n.jsxs)(a.p,{children:["If you haven't already, you will need to ",(0,n.jsx)(a.a,{href:"/docs/packaging/advanced-config/local-repository",children:"set up a local repository"})," to do stack rebuilds."]})}),"\n",(0,n.jsx)(a.h2,{id:"updating-the-library",children:"Updating the library"}),"\n",(0,n.jsxs)(a.p,{children:["Go through the steps in ",(0,n.jsx)(a.a,{href:"/docs/packaging/updating-an-existing-package",children:"Updating an Existing Package"})," as normal, but instead of running ",(0,n.jsx)(a.code,{children:"go-task build"}),", run ",(0,n.jsx)(a.code,{children:"go-task build-localcp"}),". This will automatically copy the produced package files to your local repository for use in future builds."]}),"\n",(0,n.jsx)(a.h2,{id:"what-are-symbols",children:"What are symbols?"}),"\n",(0,n.jsxs)(a.p,{children:["Updating a library often means also building its reverse dependencies against the new version due to dynamic linking. Libraries are distributed as shared object, or ",(0,n.jsx)(a.code,{children:".so"}),", files, which contain the code symbols that other software can use. These files are usually versioned, such as ",(0,n.jsx)(a.code,{children:"libpoppler.so.140"}),'. This version is called the "so version". When a piece of software is built, it is ',(0,n.jsx)(a.em,{children:"linked"})," to the versioned libraries and code symbols that it uses."]}),"\n",(0,n.jsxs)(a.p,{children:["When the developers of a library release a new update, they may decide to bump the ",(0,n.jsx)(a.code,{children:".so"})," version, and code symbols are added and/or removed from the library. If this happens, but its reverse dependencies are not rebuilt after updating, they will try to use the old shared object file and symbols. Because they no longer exist, however, the program will crash when it tries to open them. Rebuilding the stack ensures that every piece of software is pointing to the correct version of its dependencies."]}),"\n",(0,n.jsx)(a.h2,{id:"checking-if-rebuilds-are-necessary",children:"Checking if rebuilds are necessary"}),"\n",(0,n.jsxs)(a.p,{children:["That's where the ",(0,n.jsx)(a.code,{children:"abi_*"})," files in the package repository come in. ",(0,n.jsx)(a.code,{children:"abi_libs"})," and ",(0,n.jsx)(a.code,{children:"abi_symbols"})," list the libraries and code symbols provided by a package, while ",(0,n.jsx)(a.code,{children:"abi_used_libs"})," and ",(0,n.jsx)(a.code,{children:"abi_used_symbols"})," list what libraries and symbols the package links to. After updating a package that has ",(0,n.jsx)(a.code,{children:"abi_libs"})," and ",(0,n.jsx)(a.code,{children:"abi_symbols"})," files, run ",(0,n.jsx)(a.code,{children:"git diff"})," on them and check for two things:"]}),"\n",(0,n.jsxs)(a.ol,{children:["\n",(0,n.jsxs)(a.li,{children:["Changes in the ",(0,n.jsx)(a.code,{children:".so"})," version"]}),"\n",(0,n.jsxs)(a.li,{children:["Removed lines in ",(0,n.jsx)(a.code,{children:"abi_symbols"})]}),"\n"]}),"\n",(0,n.jsx)(a.p,{children:"If either of these conditions are true, then all reverse dependencies of that package need to be rebuilt."}),"\n",(0,n.jsx)(a.admonition,{type:"note",children:(0,n.jsx)(a.p,{children:"Sometimes, packages in a stack are rebuilt even though the above conditions are not met. These are called Safety Rebuilds."})}),"\n",(0,n.jsx)(a.h2,{id:"finding-reverse-dependencies",children:"Finding reverse dependencies"}),"\n",(0,n.jsxs)(a.p,{children:["In most cases, all of the required rebuilds can be found by running ",(0,n.jsx)(a.code,{children:"eopkg info <package>"})," and looking at the Reverse Dependencies line, thanks to our tooling's automatic dependency detection. This doesn't always work, though, such as with ",(0,n.jsx)(a.code,{children:"abseil-cpp"}),". In that case, you can use a tool like RipGrep to find all of the packages that link against the library you're updating, for example:"]}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-bash",children:'# Run in the root of the Solus package repository on your system\nrg "absl" packages/*/*/abi_used_libs\n'})}),"\n",(0,n.jsx)(a.h2,{id:"rebuild-the-stack",children:"Rebuild the stack"}),"\n",(0,n.jsx)(a.p,{children:"For each package in the stack, follow this procedure:"}),"\n",(0,n.jsxs)(a.ol,{children:["\n",(0,n.jsxs)(a.li,{children:["\n",(0,n.jsx)(a.p,{children:"Bump the package"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-bash",children:"go-task bump\n"})}),"\n"]}),"\n",(0,n.jsxs)(a.li,{children:["\n",(0,n.jsx)(a.p,{children:"Make sure there are no unwanted changes"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-bash",children:"git diff .\n"})}),"\n"]}),"\n",(0,n.jsxs)(a.li,{children:["\n",(0,n.jsx)(a.p,{children:"Build the package using packages in your local repository"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-bash",children:"go-task build-local\n"})}),"\n"]}),"\n",(0,n.jsxs)(a.li,{children:["\n",(0,n.jsxs)(a.p,{children:[(0,n.jsx)(a.a,{href:"/docs/packaging/updating-an-existing-package#commit-your-changes",children:"Commit your changes"}),". Use this format for your commit message:"]}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-git",children:"package: Rebuild for other-package\n"})}),"\n",(0,n.jsx)(a.p,{children:"Do this in the same git branch as the library update."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(a.p,{children:["Once all packages in the stack have been rebuilt, ",(0,n.jsx)(a.a,{href:"/docs/packaging/submitting-a-pull-request",children:"submit a pull request for review"}),". If changes are requested, see ",(0,n.jsx)(a.a,{href:"/docs/packaging/submitting-a-pull-request#amending-a-pull-request-with-multiple-commits",children:"this section"})," about amending a pull request with multiple commits."]})]})}function h(e={}){const{wrapper:a}={...(0,i.a)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(o,{...e})}):o(e)}},11151:(e,a,s)=>{s.d(a,{Z:()=>c,a:()=>r});var n=s(67294);const i={},t=n.createContext(i);function r(e){const a=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function c(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(t.Provider,{value:a},e.children)}}}]);